<?php

/**
 * Register Consumer key and secret for an application in the system.
 *
 * @param $module
 *   The Application Name.
 * @param $consumer_key
 * 	 The Consumer key.
 * @param $consumer_secret
 *   The Consumer secret.
 */
function oauth_register_key($module, $consumer_key, $consumer_secret) {
  variable_set($module . '_consumer_key', $consumer_key);
  variable_set($module . '_consumer_secret', $consumer_secret);
}

function oauth_authentication($identity, $module, $response) {
  $account = user_external_load("$identity@$module"); // '@module' is because {authmap}.authname is unique..!
  if (isset($account->uid)) {
    if (!variable_get('user_email_verification', TRUE) || $account->login) {
      // Check if user is blocked.
      $state['values']['name'] = $account->name;
      user_login_name_validate(array(), $state);
      if (!form_get_errors()) {
        // Load global $user and perform final login tasks.
        $form_state['uid'] = $account->uid;
        user_login_submit(array(), $form_state);
      }
    }
    else {
      drupal_set_message(
      t('You must validate your email address for this account before logging in via @module.',
      array('@module' => ucfirst($module)) // TODO: User friendly (hook_info).
      ));
    }
  }
  elseif (variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL)) {
    // Register new user.

    // Save response for use in MODULE_form_user_register_form_alter().
    $_SESSION[$module]['response'] = $response;

    $form_state['values'] = array();
    $form_state['values']['op'] = t('Create new account');
    drupal_form_submit('user_register_form', $form_state);

//    if (!empty($form_state['user']))

    $message = drupal_get_messages('error');
    if (empty($form_state['values']['name']) || empty($form_state['values']['mail'])) {
      // If the Service provider did not provide both a user name and an email
      // address, ask the user to complete the registration manually instead of
      // showing the error messages about the missing values generated by FAPI.
      drupal_set_message(t('Complete the registration by filling out the form below. If you already have an account, you can <a href="@login">log in</a> now and add your @module under "My account".', array('@login' => url('user/login'), '@module' => ucfirst($module))), 'warning');
    }
    else {
      drupal_set_message(t('Account registration using the information provided by your @module provider failed due to the reasons listed below. Complete the registration by filling out the form below. If you already have an account, you can <a href="@login">log in</a> now and add your @module under "My account".', array('@login' => url('user/login'), '@module' => ucfirst($module))), 'warning');
      // Append form validation errors below the above warning.
      foreach ($messages['error'] as $message) {
        drupal_set_message($message, 'error');
      }
    }

    // We were unable to register a valid new user. Redirect to the normal
    // registration page and prefill with the values we received.
    drupal_goto('user/register');
  }
  else {
    drupal_set_message(t('Only site administrators can create new user accounts.'), 'error');
  }
  drupal_goto();
}

/**
 * Add an OAuth based identity.
 *
 * @param $identity
 * 	 The external identity provided by the Service, unicity is guaranteed by the
 * 	 provider.
 * @param $module
 * 	 Module implementing the OAuth.
 * @param $access
 *   An associated array representing an acces token. Must contains the following
 *   keys: oauth_token, oauth_token_secret.
 * @param $uid
 * 	 Optional user id. If not speicified, take the user currently logged.
 */
function oauth_user_add($identity, $module, $access, $uid = NULL) {
  if (is_null($uid)) {
    global $user;
  }
  else {
    $user = new stdClass();
    $user->uid = $uid;
  }

  $fields = array('uid', 'oauth_token', 'oauth_token_secret');
  $values = array($user->uid, $access['oauth_token'], $access['oauth_token_secret']);

  user_set_authmaps($user, array("authmap_$module" => "$identity@$module"));
  db_insert($module . '_token')
    ->fields($fields, $values)
    ->execute();
}

/**
 * Menu callback; Call a hook in the module specified and inject an OAuth object.
 * 
 * These special functions need to be declared in a file called MODULE.auth.inc.
 */
function oauth_delegate($module, $hook) {
  module_load_include('inc', $module, "$module.auth");
  
  $func = $module . '_' . $hook;
  $oauth = OAuthAdapter::construct($module);
  
  $func($oauth);
}

/**
 * A class adapter implementing DrupalOAuth. Since PHP doesn't support private
 * inheritence for implementation, we are using normal inheritence.
 * Class-member attribute Module is designed to help loading consumer
 * key and secret if respecting conventions of the OAuth module, it is useful
 * for debugging as it tags its name in the watchdog.
 */
class OAuthAdapter extends OAuth implements DrupalOAuthClient {
  private $mModule;

  public static function construct($module, $signature_method = NULL, $auth_type = NULL) {
    $consumer_key = variable_get($module . '_consumer_key', '');
    $consumer_secret = variable_get($module . '_consumer_secret', '');
    $oauth = new OAuthAdapter($consumer_key, $consumer_secret, $signature_method, $auth_type);
    $oauth->mModule = $module;

    // If the user is not anonymous (can happen with cron auto-sync tasks).
    if ($GLOBALS['user']->uid != 0) {
      $oauth->setCaller($GLOBALS['user']->uid);
    }
    
    return $oauth;
  }

  public function setCaller($uid) {
    $access = db_select($this->mModule . '_token')
      ->fields($this->mModule . '_token')
      ->condition('uid', $uid)
      ->execute()
      ->fetchObject();
    parent::setToken($access->oauth_token, $access->oauth_token_secret);
  }

  public function getAccessToken($access_url, $auth_session_handle = NULL) {
    try {
      parent::setToken($_GET['oauth_token'], $_SESSION[$this->mModule]['secret']);
      $access = parent::getAccessToken($access_url, $auth_session_handle, $_GET['oauth_verifier']);

      // Replace the requestToken by a fresh accessToken from Provider.
      parent::setToken($access['oauth_token'], $access['oauth_token_secret']);
      // TODO: Save token. UPDATE it. Create placeholder on account creation.
      // TODO: Check that sessions are cleaned up correctly.
      return $access;
    } catch (OAuthException $E) {
      $response = '';
      if (!is_null($E->lastResponse)) {
        $response = $E->lastResponse;
      }
      $message = $E->getMessage();
      if (!is_null($E->getPrevious())) {
        $message = $E->getPrevious()->getMessage() . '\n' . $message;
      }
      watchdog($this->mModule, 'Error establishing an access token : @message\n@response', array('@message' => $message, '@response' => $response), WATCHDOG_ERROR);
    }
  }

  public function getRequestToken($request_url, $callback = NULL) {
    // Setting up variables
    $random = md5(rand());
    if (is_null($callback)) {
      // TODO: put back module/oauth_callback when http://drupal.org/node/1087940
      // get fixed.
      $callback = 'oauth/' . $this->mModule . '/oauth_callback';
    }
    $callback = url($callback, array('query' => array('action' => $random), 'absolute' => TRUE));

    try {
      $request = parent::getRequestToken($request_url, $callback);

      // Put variables in a session and create a token placeholder.
      $_SESSION[$this->mModule]['secret'] = $request['oauth_token_secret'];
      $_SESSION[$this->mModule]['random'] = $random;
      return $request;
    } catch(OAuthException $E) {
      $response = '';
      if (!is_null($E->lastResponse)) {
        $response = $E->lastResponse;
      }
      $message = $E->getMessage();
      if (!is_null($E->getPrevious())) {
        $message = $E->getPrevious()->getMessage() . '\n' . $message;
      }
      watchdog($this->mModule, 'Error establishing an access token : @message\n@response', array('@message' => $message, '@response' => $response), WATCHDOG_ERROR);
    }
  }
}

interface DrupalOAuthClient {

  /**
   * Constructor. We can't overrides the constructor with PECL OAuth, so we
   * delegate the instanciation to this function.
   *
   * @param $module
   *	 The application for which the object is created.
   */
  static function construct($module, $signature_method = NULL, $auth_type = NULL);

  /**
   * Set the user associated Access Token and Secret Token for this DrupalOAuth
   * instance. It is the responsibility of the caller to check if token exists.
   *
   * @param $uid
   *   The user id.
   */
  function setCaller($uid);

  /**
   * Turns off verbose request information (off by default).
   */
  function disableDebug();

  /**
   * Disable redirects from being followed automatically, thus allowing the
   * request to be manually redirected.
   */
  function disableRedirects();

  /**
   * Turns off the usual SSL peer certificate and host checks, this is not for
   * production environments.
   */
  function disableSSLChecks();

  /**
   * Turns on verbose request information useful for debugging.
   */
  function enableDebug();

  /**
   * Follow and sign redirects automatically, which is enabled by default.
   */
  function enableRedirects();

  /**
   * Turns on the usual SSL peer certificate and host checks (enabled by default).
   */
  function enableSSLChecks();

  /**
   * Fetch a resource.
   *
   * @param $url
   * 	 URL to the OAuth protected resource.
   * @param $extra
   * 	 Extra parameters to send with the request for the resource.
   * @param $http_method
   *   One of the OAUTH_HTTP_METHOD_* OAUTH constants, which includes GET, POST,
   *   PUT, HEAD, or DELETE.
   *
   *   HEAD (OAUTH_HTTP_METHOD_HEAD) can be useful for discovering information
   *   prior to the request (if OAuth credentials are in the Authorization header).
   * @param $http_headers
   * 	 HTTP client headers (such as User-Agent, Accept, etc.)
   *
   * @return
   * 	 Returns TRUE on success or FALSE on failure.
   */
  function fetch($url, $extra = NULL, $http_method = NULL, $http_headers = array());

  /**
   * Fetch an access token, secret and any additional response parameters from
   * the service provider.
   *
   * @param $access_url
   * 	 URL to the access token API.
   * @param $auth_session_handle
   *   Authorization session handle, this parameter does not have any citation
   *   in the core OAuth 1.0 specification but may be implemented by large
   *   providers. @see http://oauth.pbwiki.com/ScalableOAuth/
   *   for more information.
   */
  function getAccessToken($access_url, $auth_session_handle = NULL);

  /**
   * Gets the Certificate Authority information, which includes the ca_path and
   * ca_info set by OAuth::setCaPath().
   */
  function getCAPath();

  /**
   * Get the raw response of the most recent request.
   */
  function getLastResponse();

  /**
   * Get HTTP information about the last response.
   */
  function getLastResponseInfo();

  /**
   * Fetch a request token, secret and any additional response parameters from
   * the service provider. Sets a random number associated with the request to
   * avoid unauthorized call on the callback URL. This mecanism can be improved
   * by redefining this method on a subclass.
   *
   * The response contains the following parameters:
   * 	- oauth_token:
   * 			The Request Token.
   *  - oauth_token_secret:
   *  		The Token Secret.
   *  - Additional parameters:
   *  		Any additional parameters, as defined by the Service Provider.
   *
   * @param $request_url
   *   URL to the request token API.
   * @param $callback
   *   Optinal OAuth callback URL. Default to 'oauth/module/oauth_callback'
   *   
   *   TODO: put back module/oauth_callback when http://drupal.org/node/1087940
   *   get fixed.
   *
   * @return
   *   Returns TRUE if a parameter is correctly set, otherwise FALSE (e.g., if
   *   an invalid auth_type is passed in.)
   */
  function getRequestToken($request_url, $callback = NULL);

  /**
   * Set where the OAuth parameters should be passed.
   *
   * @param $auth_type
   * auth_type can be one of the following flags (in order of decreasing
   * preference as per OAuth 1.0 section 5.2):
   *
   *   OAUTH_AUTH_TYPE_AUTHORIZATION
   * 		 Pass the OAuth parameters in the HTTP Authorization header.
   * 	 OAUTH_AUTH_TYPE_FORM
   * 		 Append the OAuth parameters to the HTTP POST request body.
   *   OAUTH_AUTH_TYPE_URI
   * 	   Append the OAuth parameters to the request URI.
   *   OAUTH_AUTH_TYPE_NONE
   * 	   None.
   */
  function setAuthType($auth_type);

  /**
   * Sets the Certificate Authority (CA), both for path and info.
   *
   * @param $ca_path
   * 	 The CA Path being set.
   * @param $ca_info
   *   The CA Info being set.
   *
   * @return
   *   Returns TRUE on success, or FALSE if either ca_path or ca_info are
   *   considered invalid.
   */
  function setCAPath($ca_path, $ca_info);

  /**
   * Sets the nonce for all subsequent requests.
   *
   * @param $nonce
   *   The value for oauth_nonce.
   *
   * @return
   *   Returns TRUE on success, or FALSE if the nonce is considered invalid.
   */
  function setNonce($nonce);

  /**
   * Sets the Request Engine, that will be sending the HTTP requests.
   * PECL OAuth >= 1.0.0
   *
   * @param $reqengine
   *   The desired request engine. Set to OAUTH_REQENGINE_STREAMS to use PHP
   *   Streams, or OAUTH_REQENGINE_CURL to use Curl.
   */
//  function setRequestEngine($reqengine);

  /**
   * Sets the RSA certificate.
   * PECL OAuth >= 1.0.0
   *
   * @param $cert
   *   The RSA certificate.
   *
   * @return
   *   Returns TRUE on success, or FALSE on failure (e.g., the RSA certificate
   *   cannot be parsed.)
   */
//  function setRSACertificate($cert);

  /**
   * Sets the OAuth timestamp for subsequent requests.
   * PECL OAuth >= 1.0.0
   *
   * @param $timestamp
   *   The timestamp.
   *
   * @return
   *   Returns TRUE, unless the timestamp is invalid, in which case FALSE is
   *   returned.
   */
//  function setTimestamp($timestamp);

  /**
   * Set the token and secret for subsequent requests.
   *
   * @param $token
   *   The OAuth token.
   * @param $token_secret
   *   The OAuth token secret.
   *
   * @return
   *   TRUE
   */
  function setToken($token, $token_secret);

  /**
   * Sets the OAuth version for subsequent requests
   *
   * @param $version
   *   OAuth version, default value is always "1.0"
   *
   * @return
   *   Returns TRUE on success or FALSE on failure.
   */
  function setVersion($version);
}